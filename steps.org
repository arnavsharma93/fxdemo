* New
When Run() is called, Fx will:

Print all types available using the PROVIDE log line (more on this later).
Print RUNNING once the app has started successfully.
Block until either SIGINT or SIGTERM is received.
Gracefully shut down, causing the process to exit.

Send a SIGINT now by typing Ctrl+C into the console:
#+BEGIN_SRC go
package main

import (
	"go.uber.org/fx"
)

func main() {
	app := fx.New()
	app.Run()

}
#+END_SRC
* Provide
Fx apps are built around types, which are made available to your application
via dependency injection using fx.Provide.
If you run your Fx app, you can see a log statement starting with PROVIDE:
To build any functionality, you must provide your own types by following these two steps:

1. Write a constructor that creates a type.
#+BEGIN_SRC go
// NewHandler function instantiates our handler
func NewHandler() http.Handler {
	fmt.Println("Constructing a new http handler")

	handler := func(w http.ResponseWriter, r *http.Request) {
		fmt.Println("Handler was called")
		_, err := io.WriteString(w, "hello world\n")
		if err != nil {
			log.Println("err, please do something ", err)
		}
	}

	return http.HandlerFunc(handler)
}
#+END_SRC
2. Pass the constructor to fx.New() using the fx.Provide() option.
#+BEGIN_SRC go
	app := fx.New(
		fx.Provide(NewHandler),
	)
#+END_SRC

Start by introducing an http.Handler type by adding the following constructor
under your main() func:
Notice that you didn't see the output Constructing an http.Handler when you ran the
application.
This is because Fx never called NewHandler. It only made the type available.
Put differently, the constructors supplied via fx.Provide are called lazily.
* Invoke
fx.Provide makes types available, but how do we use these types? With fx.Invoke.

fx.Invoke allows you to supply functions that:

1. Will always be executed when your app is run.
2. Have access to all types provided to the app.

Think of functions supplied to fx.Invoke as the entry point: they introduce your
serviceâ€™s top-level objects to each other.

For example, you might use an invoked function to register all your HTTP handlers with a mux,
to bind your RPC procedures to the network, or to wire your message handlers up
to a Kafka queue. Without fx.Invoke, Fx wouldn't know what code needs to run or which
types need to be nstantiated.

1. Set up invoke
#+BEGIN_SRC go

		fx.Invoke(Register),

// Register the http handler
func Register(handler http.Handler) {
	// TODO: do the actual registering
	fmt.Printf("register the handler %v against %v\n", handler, "something")

}
#+END_SRC

The [Fx] INVOKE main.Register() line indicates that main.Register was executed as promised.
You can also see that every type required to call Register was instantiated:

2. Provide mux
Next, you need to make the Register function actually register the http.Handler against
a *http.ServeMux. To do that, provide the type *http.ServeMux by adding the
following constructor below main():

Great! *http.ServeMux is now available.
Update Register to register the handler against the *http.ServeMux:

#+BEGIN_SRC go

		fx.Provide(
			NewHandler,
			NewServeMux,
		),

// NewServeMux provides a new serve mux
func NewServeMux() *http.ServeMux {
	fmt.Println("construting a new serve mux")
	mux := http.ServeMux{}
	// TODO: do something with the request here

	return &mux
}

// Register the http handler
func Register(handler http.Handler, mux *http.ServeMux) {
	// TODO: do the actual registering
	fmt.Printf("register the handler %#v against %T\n", handler, mux)
	mux.Handle("/", handler)

}
#+END_SRC
* LifeCycle
The first PROVIDE printed when your app runs is fx.Lifecycle:

#+BEGIN_SRC sh
$ go run main.go
[Fx] PROVIDE	    fx.Lifecycle <= vendor/go.uber.org/fx.New.func1()
	...

#+END_SRC
Long-running workloads, like the ones described in the previous section,
need a way to hook into process lifecycle (the startup and shutdown of a process).
Fx provides the type fx.Lifecycle, which enables exactly that.

To see how this works, update NewServeMux to use fx.Lifecycle:
1. Write hooks and append them to lifecycle
#+BEGIN_SRC go
// NewServeMux provides a new serve mux
func NewServeMux(lifecycle fx.Lifecycle) *http.ServeMux {
	fmt.Println("construting a new serve mux")
	mux := http.ServeMux{}
	lifecycle.Append(fx.Hook{
		OnStart: func(context.Context) error {
			fmt.Println("starting http server")
			return nil
		},
		OnStop: func(context.Context) error {
			fmt.Println("stopping http server")
			return nil
		},
	})

	return &mux
}

#+END_SRC

2. Get new serve mux, create new http server, and start on OnStart
#+BEGIN_SRC go

func NewServeMux(lifecycle fx.Lifecycle) *http.ServeMux {
	fmt.Println("construting a new serve mux")
	mux := http.NewServeMux()

	server := &http.Server{
		Addr:    ":8080",
		Handler: mux,
	}
	lifecycle.Append(fx.Hook{
		OnStart: func(context.Context) error {
			fmt.Println("starting http server")
			// ignoring error handling for brevity
			go server.ListenAndServe()
			return nil
		},
		OnStop: func(ctx context.Context) error {
			fmt.Println("stopping http server")
			return server.Shutdown(ctx)
		},
	})

	return mux
}
#+END_SRC
* Options
In the previous section, you finished building an Fx app from scratch.
The app contained two types of code:

1. Business logic unique to your app: the handler provided by NewHandler.
2. Code required to set up the HTTP server: the mux provided by NewServeMux and
invoked by Register.

1. New serverfx
#+BEGIN_SRC go

// Module allows the module to provide multiple constructors and functions to invoke
// through a single variable using fx.Options
var Module = fx.Options(
	fx.Provide(NewServeMux),
	fx.Invoke(Register),
)
#+END_SRC
2. Import it

#+BEGIN_SRC go
	"github.com/arnavsharma93/fxdemo/serverfx"
#+END_SRC

Fantastic.
Now your app only contains business logic, and none of the code required to set up the
HTTP server!
If other apps want to use serverfx, it can easily be moved to its own repo to be
versioned and distributed independently.
2. Create logfx
#+BEGIN_SRC go
// Module provides the *log.Logger
var Module = fx.Options(
	fx.Provide(NewLogger),
)

// NewLogger instantiates a logger which can be used throughout
func NewLogger() *log.Logger {
	logger := log.New(os.Stdout, "[fxdemo] ", 0)
	logger.Print("Instantiating a logger")
	return logger

}
#+END_SRC
3. Create a common fxdemofx
#+BEGIN_SRC go
// Module provides common modules which can be picked up by other projects
var Module = fx.Options(
	logfx.Module,
	serverfx.Module,
)
#+END_SRC
