* Engineering
- Trip scale - solving complicated distributed problems like realtime pnl
- Rely heavily on kafka, golang, cassandara and other open source solutions

* Why Go@Uber?
** Engineering growth
 300 - 2014
 1000 - 2015
 2000 - 2016
 3000 - 2017

* Golang features
| Feature                                                 | Help line                                                                       |
| Performant and productive                               | The joke goes that Go was developed while waiting for a C++ program to compile. |
| Has fewer features - lower learning curve.              | Team onobarded quickly                                                          |
| Canonical styling - no fighting over unnecessary stuff. | gofmt, formatters, linters                                                      |
| Lower compute and memory footprint.                     | uber services used lower, trademarks show lower usage                           |
| Great inbuilt tooling for CPU and memory profiling.     | profilers                                                                       |
| Simple type system - offers compile time safety.        | maintainable code, catch errors at compile time                                 |
| Inbuilt memory safety                                   | 21st century code, inbuilt garbage collector                                    |
| Concurrency                                             | goroutines, channel - no futures, messy callbacks, yields                       |
| Binary                                                  | ease of deploying, no run time loading                                          |
| Understand go                                           | don't apply same solutions, understand paradigm                               |
| Bad dependency management                               | glide sucks, godep is in works                                                  |
| 3rd party solutions                                     | Not at the same level as Python but getting better                         |

* UberFx
Fx is an application framework for Go that:
1. Composable and testable apps
2. Boilerplate in main and the need for global state and package-level init functions.
3. Using dependency injection.

* New
When Run() is called, Fx will:

1. Print all types - PROVIDE log line
2. Print RUNNING once - success
3. Block until either SIGINT or SIGTERM is received.
4. Gracefully shut down, causing the process to exit.

Send a SIGINT now by typing Ctrl+C into the console:
#+BEGIN_SRC go
package main

import (
	"go.uber.org/fx"
)

func main() {
	app := fx.New()
	app.Run()

}
#+END_SRC
* Provide
- Fx apps are built around types, via dependency injection using fx.Provide.
- Log - PROVIDE line

To build any functionality, you must provide your own types by following these two steps:
- Write a constructor that creates a type.
- Pass the constructor to fx.New() using the fx.Provide() option.

1 Write a constructor that creates a type.
#+BEGIN_SRC go
// NewHandler function instantiates our handler
func NewHandler() http.Handler {
	fmt.Println("Constructing a new http handler")

	handler := func(w http.ResponseWriter, r *http.Request) {
		fmt.Println("Handler was called")
		_, err := io.WriteString(w, "hello world\n")
		if err != nil {
			log.Println("err, please do something ", err)
		}
	}

	return http.HandlerFunc(handler)
}
#+END_SRC
2 Pass the constructor to fx.New() using the fx.Provide() option.
#+BEGIN_SRC go
	app := fx.New(
		fx.Provide(NewHandler),
	)
#+END_SRC
** Will handler was called be printed?
- Notice that you didn't see the output , as FX never called NewHandler
- Put differently, the constructors supplied via fx.Provide are called lazily.

* Invoke
- fx.Provide makes types available, but how do we use these types? With fx.Invoke.
- fx.Invoke allows you to supply functions that:
  1. Have access to all provided types
  2. Always get executed
  3. Think of them as entry points

- For example, you might use an invoked function to register all your HTTP handlers with a mux,
to bind your RPC procedures to the network

- Set up invoke
#+BEGIN_SRC go

		fx.Invoke(Register),

// Register the http handler
func Register(handler http.Handler) {
	// TODO: do the actual registering
	fmt.Printf("register the handler %v against %v\n", handler, "something")

}
#+END_SRC

_What will get printed now?_ Would we see constructor line?
  - The [Fx] INVOKE main.Register() line indicates that main.Register was executed as promised.
  - Every time instantiated

- Provide mux
  - Provide mux
  - Update register to take mux
#+BEGIN_SRC go

		fx.Provide(
			NewHandler,
			NewServeMux,
		),

// NewServeMux provides a new serve mux
func NewServeMux() *http.ServeMux {
	fmt.Println("construting a new serve mux")
	mux := http.ServeMux{}
	// TODO: do something with the request here

	return &mux
}

// Register the http handler
func Register(handler http.Handler, mux *http.ServeMux) {
	// TODO: do the actual registering
	fmt.Printf("register the handler %#v against %T\n", handler, mux)
	mux.Handle("/", handler)

}
#+END_SRC
* LifeCycle
- The first PROVIDE printed
#+BEGIN_SRC sh
$ go run main.go
[Fx] PROVIDE	    fx.Lifecycle <= vendor/go.uber.org/fx.New.func1()
	...

#+END_SRC
- Need something to do
  - Long-running workloads, like starting a server.
  - Hook into process lifecycle (the startup and shutdown of a process).
Fx provides the type fx.Lifecycle, which enables exactly that.

To see how this works, update NewServeMux to use fx.Lifecycle:
1. Write hooks and append them to lifecycle
#+BEGIN_SRC go
// NewServeMux provides a new serve mux
func NewServeMux(lifecycle fx.Lifecycle) *http.ServeMux {
	fmt.Println("construting a new serve mux")
	mux := http.ServeMux{}
	lifecycle.Append(fx.Hook{
		OnStart: func(context.Context) error {
			fmt.Println("starting http server")
			return nil
		},
		OnStop: func(context.Context) error {
			fmt.Println("stopping http server")
			return nil
		},
	})

	return &mux
}

#+END_SRC

2. Get new serve mux, create new http server, and start on OnStart
#+BEGIN_SRC go

func NewServeMux(lifecycle fx.Lifecycle) *http.ServeMux {
	fmt.Println("construting a new serve mux")
	mux := http.NewServeMux()

	server := &http.Server{
		Addr:    ":8080",
		Handler: mux,
	}
	lifecycle.Append(fx.Hook{
		OnStart: func(context.Context) error {
			fmt.Println("starting http server")
			// ignoring error handling for brevity
			go server.ListenAndServe()
			return nil
		},
		OnStop: func(ctx context.Context) error {
			fmt.Println("stopping http server")
			return server.Shutdown(ctx)
		},
	})

	return mux
}
#+END_SRC

_What will get printed first?_ starting http server or provide invoke statements

* Options
The app contained two types of code:
1. Business logic unique to your app: the handler provided by NewHandler.
2. Code required to set up the HTTP server: the mux provided by NewServeMux and
invoked by Register.

- Great to separate responsibilities
- Resuability of modules, distribute independently

- New serverfx
#+BEGIN_SRC go

// Module allows the module to provide multiple constructors and functions to invoke
// through a single variable using fx.Options
var Module = fx.Options(
	fx.Provide(NewServeMux),
	fx.Invoke(Register),
)
#+END_SRC
2. Import it
#+BEGIN_SRC go
	"github.com/arnavsharma93/fxdemo/serverfx"
#+END_SRC
3. Add it to main.go
_how should it be added? provided or invoked? or something else?_

If other apps want to use serverfx, it can easily be moved to its own repo to be
versioned and distributed independently.
2. Create logfx
#+BEGIN_SRC go
// Module provides the *log.Logger
var Module = fx.Options(
	fx.Provide(NewLogger),
)

// NewLogger instantiates a logger which can be used throughout
func NewLogger() *log.Logger {
	logger := log.New(os.Stdout, "[fxdemo] ", 0)
	logger.Print("Instantiating a logger")
	return logger

}
#+END_SRC
3. Create a common fxdemofx
#+BEGIN_SRC go
// Module provides common modules which can be picked up by other projects
var Module = fx.Options(
	logfx.Module,
	serverfx.Module,
)
#+END_SRC
